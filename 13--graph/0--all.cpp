// 1
// Number of undirected graphs that can be formed using 'N' vertices

// 2
// Print Adjacency List

// 3
// Number of Provinces

// 4
// BFS

// 5
// DFS

// 6
// Number of provinces -- leetcode 547

// 7
// *** Multisource dfs
// Little optimization : count fresh oranges and fresh to rotten oranges conversion
// Rotting Oranges -- leetcode 994

// 8
// *** if the given cell color and converted color is the same then it may go to infinite loop if not handled properly
// Flood fill algorithm -- leetcode 733

// 9 
// *** Using DFS is tricky
// Detect cycle in undirected graph -- Using BSF & DSF

// 10
// *** Need to find distance of every cell
// 0 1 Matrix -- leetcode 542

// 11
// ***Surrounded Region -- leetcode 130

// 12
// *** Number of enclaves -- leetcode 1020

// 13
// Word Ladder 1 -- leetcode 127

// 14
// Distinct Island -- Coding Ninjas

// 15
// Is Bipartite -- leetcode 785

// 16
// Detect cycle in Directed Graph -- Coding Ninjas

// 17
// Topological Sorting -- Coding Ninjas

// 18
// Course schedule I -- leetcode 207

// 19
// Course schedule II -- leetcode 210

// 20
// Find Eventual Safe States -- leetcode 802

// 21
// Alien Dictionary -- leetcode 269

// 22
// Sortest path in Undirected and Unweighted graph 

// 23
// Why we need to do topo sort, this is important (To understand clearly, we need to dry run)
// Shortest path in directed acyclic graph -- Coding Ninjas ***

// 24
// Dijkstra's algorithm

// 25
// Shortest Path in Weighted undirected graph -- Geeks

// 26
// Shortest path in binary matrix -- leetcode 1091

// 27
// Path with minimum effort -- leetcode 1631

// 28 ***
// Cheapest flight within k stop -- leetcode 787

// 29
// Network delay time -- leetcode 743

// 30 ***
// Number of ways to reach a destination -- leetcode 1976

// 31
// Minimum multiplication operations to reach from start to end -- Coding Ninjas

// 31
// Bellman Ford Algorithm -- Works on graph having negative cycle

// 32
// Floyd Warshall Algorithm 
// As the given question, only negative edge exist and negative cycle does not exist
// And it was single source shortest path, we can solve this using Dijkstra

// 33
// Find city with smaller number of Neighbors -- leetcode 1334

// 34
// Minimum Spanning Tree (Prime's algorithm) -- Coding Ninja -- Geeks

// 35
// Minimum Spanning Tree (Kruskal's algorithm) -- Coding Ninja -- Geeks

// 36
// Number of operations to make network connected -- leetcode 1319

// Q1
// Number of Islands -- leetcode 200